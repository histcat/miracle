---
abbrlink: ''
categories:
- - oi
date: '2023-09-24T18:36:57.556621+08:00'
tags:
- oi
title: P3205 [HNOI2010] 合唱队
updated: 2023-9-24T18:37:9.833+8:0
---
# 题目

为了在即将到来的晚会上有更好的演出效果，作为 AAA 合唱队负责人的小 A 需要将合唱队的人根据他们的身高排出一个队形。假定合唱队一共 $n$ 个人，第 $i$ 个人的身高为 $h_i$ 米（$1000 \le h_i \le 2000$），并已知任何两个人的身高都不同。假定最终排出的队形是 $A$ 个人站成一排，为了简化问题，小 A 想出了如下排队的方式：他让所有的人先按任意顺序站成一个初始队形，然后从左到右按以下原则依次将每个人插入最终棑排出的队形中：

- 第一个人直接插入空的当前队形中。
- 对从第二个人开始的每个人，如果他比前面那个人高（$h$ 较大），那么将他插入当前队形的最右边。如果他比前面那个人矮（$h$ 较小），那么将他插入当前队形的最左边。

当 $n$ 个人全部插入当前队形后便获得最终排出的队形。

例如，有 $6$ 个人站成一个初始队形，身高依次为 $1850, 1900, 1700, 1650, 1800, 1750$，那么小 A 会按以下步骤获得最终排出的队形：

- $1850$。
- $1850, 1900$，因为 $1900 > 1850$。
- $1700, 1850, 1900$，因为 $1700 < 1900$。
- $1650, 1700, 1850, 1900$，因为 $1650 < 1700$。
- $1650, 1700, 1850, 1900, 1800$，因为 $1800 > 1650$。
- $1750, 1650, 1700, 1850, 1900, 1800$，因为 $1750 < 1800$。

因此，最终排出的队形是 $1750, 1650, 1700, 1850, 1900, 1800$。

小 A 心中有一个理想队形，他想知道多少种初始队形可以获得理想的队形。

请求出答案对 $19650827$ 取模的值。

对于 $100\%$ 的数据，$n \le 1000$，$1000 \le h_i \le 2000$。


# 题解

> 为什么要用区间dp？（引用于题解）

我们发现区间 dp 有一个性质——大区间包含小区间，这道题就符合这样的一个性质:

![](https://cdn.luogu.com.cn/upload/pic/75397.png)

首先我们设`f[i][j]`表示符合理想区间i到j的方案数。dp的转移靠的是最后一个不同之处，即最后一个数是插入在左面还是右面，然而发现——很难转移

于是设`f[0/1][i][j]`表示符合理想区间i到j的方案数（0代表最后一个数是在左面插入，即为第i个，1则反之），然后分类讨论转移即可


# 代码

```cpp
#include<bits/stdc++.h>

using namespace std;
const int N = 1010;
const int mod = 19650827;
int n, a[N];

int read()
{
	int f = 1, x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9')
	{
		if(ch == '-') f = -1;
		ch = getchar();
	}

	while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return f * x;
}

int f[N][N][2];

int main()
{
	n = read();
	for(int i = 1;i <= n;i++)
	{
		a[i] = read();
	}

	for(int i = 1;i <= n;i++)
	{
		f[i][i][0] = 1;
	}

	for(int L = 2;L <= n;L++)
	{
		for(int i = 1;i + L - 1 <= n;i++)
		{
			int j = i + L - 1;
		
			if(a[i + 1] > a[i])
				f[i][j][0] += f[i + 1][j][0];
			if(a[j] > a[i])
				f[i][j][0] += f[i + 1][j][1];
			if(a[i] < a[j])
				f[i][j][1] += f[i][j - 1][0];
			if(a[j - 1] < a[j])
				f[i][j][1] += f[i][j - 1][1];
			f[i][j][0] %= mod, f[i][j][1] %= mod;
		}
	}

	cout << (f[1][n][0] + f[1][n][1]) % mod;

	return 0;
}
```
