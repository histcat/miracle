---
abbrlink: ''
categories:
- - oi
date: '2023-01-25 22:47:55'
mathjax: true
tags:
- oi
- 位运算
title: 蓝书0x01
updated: '2023-01-26 13:05:31'
---
# 位运算

## 作用

计算机底部实现方式是二进制，熟练运用并掌握位运算可以提高程序运行的时空效率

## 彩蛋

蓝书前言编号0xFF 为 -1，后记为0x7F 为 127（在有符号8位二进制数的条件下）

## 初步认识

1. 与：and，&，∧（可以与集合运算联合起来记忆）
2. 或：or，|，∨
3. 非：not，~，¬
4. 异或：xor，^

在$m$位二进制数中，最低位通常为第$0$位，从右往左递加，最高位为$m-1$位

## 整数的存储与运算

下面以32位二进制数，即C++中的int和unsigned int 为例子介绍。

### 补码

1. unsigned int
   直接把编码C看成32位二进制数S
2. int
   最高位为符号位，0表示**非**负数，1表示负数。
   符号位为0的，直接把编码C看成32位二进制数S。
   符号位为1的，定义该编码C按位取反后得到的~C表示的数值为$-1-S$

   可发现，在补码下每个数值有唯一的表示方法 并且任意两个数值做加减法时，都等价在32位补码下做**最高位不进位**（就是最高位溢出的话直接不管了1+1=0，但倒数第二位的进位要进，类似这种）的二进制加减法运算。溢出时，32位**无**符号整数相当于自动对$2^32$取模。这也解释了“有符号整数”算数上溢时出现负数的现象。（然而并没看懂，有无dalao帮忙解答一下）

### 反码

略过，就是比补码少加1

### 简单表示

用二进制表示一个int要32位，比较繁琐，采用十进制又表现不出补码的每一位，所以常用十六进制表示一个常数。这样只用8个字符。
常用数值：0x3F3F3F3F （2倍不会溢出，每个字节相同，方便赋值）

## 移位运算

左移：在二进制表示下把数字向左移动，低位补0，高位越界舍弃。
$1 << n = 2^n$
$n << 1 = 2 \times n$
算数右移：二进制补码表示下，把数字同时向右移动，高位以符号位填充，低位越界后舍弃。等同于除以2后向下取整。（$(-3)>>1=-2$）
逻辑右移：二进制补码表示下，把输出同时向右移动，高位以**0**填充，低位越界后舍弃。
一般的编译器均使用算数右移。

## 应用

1. 求$a^b mod p$

   (未完待续)
