---
abbrlink: ''
categories:
- oi
date: '2022-07-15 09:56:37'
mathjax: true
tags:
- oi
- 多重背包
title: 单调队列优化多重背包
updated: '2022-08-12 22:00:56'
---首先说一些写本文时的悲惨经历，一开始我是使用Gridea，编辑也是用它的编辑器，但是，在一次写作中，电脑无征兆地蓝屏了。我重启之后发现md文件打不开了，查看了一下二进制全是0 emmm（编写过程中保存了！！）。自此我换成了hexo emmm。

## 符号定义

首先我们定义一些符号，物品个数为 $n$ ，
第 $i$ 个物品的体积为 $v_i$ ，价值为 $w_i$ , 最多为 $s_i$ 个。
背包的体积为 $V$，动归数组为 $dp$ .

有时候为了方便，在 $i$ 确定的前提下，把 $v_i$ ，$w_i$ 简写成 $v$，$w$

## 回顾

我们先回顾多重背包的优化，（ $x$ 是 背包体积为 $j$ 时，背包能够承受的最大个数，即 $j / v$）
设此时第 $i$ 个物品的体积为 $v$ .

```cpp
dp[i, j]= max(dp[i - 1, j], dp[i - 1, j - v] + w, dp[i - 1, j - 2v] + 2w, ......,dp[i - 1, j - (x - 1) v] + (x - 1)w, dp[i - 1, j - xv] + xw)
```

然后我们来思考，完全背包时，$dp[i,j]$ 和 $dp[i,j - v]$ 的联系

```cpp
dp[i, j - v]= max(dp[i - 1, j - v], dp[i - 1, j - 2v] + w, dp[i - 1, j - 3v] + 2w, ......, dp[i - 1, j - (x - 1) v] + (x - 2)w, dp[i - 1, j - xv] + (x - 1)w)
```

（有的同学可能会问最后一个背包能承受的数量为什么还是 $x$ ，但其实那不是 $x$ ，是 $ (x - 1)v - v $ 即 $xv$ ）

然后我们惊奇地发现， $max()$ 第一项之后的 和 $dp[i,j - v]$ 是如此的相似，只差了个 $w$ ，所以我们可以把 $w$移出来，替换成

```cpp
dp[i, j]= max(dp[i - 1, j], dp[i][j - v] + w)
```

## 否定

然后我们来看多重背包，我们还推柿子看看（我们先假设此时 $j$ 远大于 $sv$ ）

我们先尝试能否用完全背包的方法来优化，

```cpp
dp[i, j]= max(dp[i - 1, j], dp[i - 1, j - v] + w, dp[i - 1, j - 2v] + 2w, ......,dp[i - 1, j - (s - 1) v] + (s - 1)w, dp[i - 1, j - sv] + sw
```

```cpp
dp[i, j - v]= max(dp[i - 1, j - v], dp[i - 1, j - 2v] + w, dp[i - 1, j - 3v] + 2w, ......, dp[i - 1, j - (s - 1) v] + (s - 2)w, dp[i - 1, j - sv] + (s - 1)w)
```

看起来似乎很对，是吗？（

但是我们考虑一下项数，我们会发下 $dp[i, j-v]$ 的项数 和 $dp[i,j]$相同，都是 $s$ 项 ，不和 $max()$ 第一项之后的 项数相同，从而不能使用之前的方法优化

## 展新

（从这一小节开始用一维数组，方便表示，没学过一维数组表示的去学一下 ）

我们还是考虑 $dp[j]$，还是列柿子

```cpp
dp[j]= max(dp[j], dp[j - v] + w, dp[j - 2v] + 2w, ......,dp[j - (s - 1) v] + (s - 1)w, dp[j - sv] + sw
```

我们观察这个柿子，很容易得出一个性质，会更新状态 $j$ 的状态和 $j$ 都是模 $v$ 意义下**同余**的。于是我们把状态 $1$到$V$ 按模 $v$ 的余数划分成 $v$ **类**，分别是模 $v$ 余 $0$ 的，模 $v$ 余 $1$ 的，$\cdots$，模 $v$ 余 $v-2$ 的，以及模 $v$ 余 $v-1$ 的。

原来的`dp[1]~dp[V]`我们就可以变化成这 $v$ 类（这里比较难想，但一定要想明白）

```cpp
dp[0]   dp[v]     dp[2v]     dp[3v]     ... dp[kv]
dp[1]   dp[1+v]   dp[1+2v]   dp[1+3v]   ... dp[1+kv]
dp[2]   dp[2+v]   dp[2+2v]   dp[2+3v]   ... dp[2+kv]
...
dp[v-1] dp[v-1+v] dp[v-1+2v] dp[v-1+3v] ... dp[v-1+kv]
```

然后我们就可以在这 $v$ 类**分别更新**了，写一下这样的代码

```cpp
for(int i = 1;i <= n;i++)
{
    for(u = 0;u < v[i];u++)
    {
        for(int k = u;k <= V;k += v[i])
        {
            for(int t = min(k - s * v[i], u)/*防止减到负数*/;t < k;t += v[i])
            {
                dp[k] = max(dp[k], dp[t] + (k - t) / v[i] * w[i]);
            }
        }
	}
}
```

对，你没有看错，这是四层循环，也许你要问了，~~这循环怎么还越搞越多了~~，但是让我们分析一下他的时间复杂度。第一层循环 $O(n)$，第二层循环是枚举每一类的起始值的，第三层是枚举该类里每一个状态的，二三层的总共时间复杂度是 $O(V)$，最后一层就是枚举 可以转移到当前状态的状态，是 $O(s)$ 的，所以总共时间复杂度还是 $O(nms)$ 的。

## 单调队列优化

也许你要问了，~~说了这么多怎么连单调队列的影子都没看见~~，其实我们之前做的都是为了ta做铺垫，ta这不就来了。

首先，我们要优化的就是上面的代码的第四层：由当前状态的前面 $s$ 个（不相邻的，每两个相差 $v$）状态来更新当前状态。

我们从感性地角度来思考一下，上图！（qwq

![mul-p1](https://cdn.staticaly.com/gh/JesseJeson/picture-api@master/20220811/mul-p1.4f1ei1086w40.png)

我们来看这个图， $j$ 这里表示的就是当前状态 ，$j'$表示的是下一个状态 即 $j + v$，灰色格子表示的是  ***可以更新当前状态（这里为 $j$ 或 $j'$）**的状态*

**！！！！！注意：图片里第一行最左面的应该是 $j-sv$ 手贱写错了（懒得改了emmm）**

我们可以观察出来，**状态**每增加 $v$ ta的式子`dp[j]= max(dp[j], dp[j - v] + w, dp[j - 2v] + 2w, ......,dp[j - (s - 1) v] + (s - 1)w, dp[j - sv] + sw`就会失去最后（图上最左）面的一个  可以更新ta的状态  ，同时也得到了最前（图上最右）面的一个 可以更新ta 的状态。

让我们思考一下，可以在两端插入，删除数据，并支持较小 （$O(1)$）的时间复杂度求最大值的数据结构是什么？**单调队列**！

## 一些小细节

to be continued

